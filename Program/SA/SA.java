package Program.SA;
/*
SA
*/
//random for integers
import java.util.*;
//random for doubles
import java.lang.Math;
import Program.TSP.Solution;
import Program.TSP.TSP;
import Program.LS.*;

public class SA {
	/*
	tsp 			- the tsp 
	s				- the starting solution
	coolingFactor	- how much we multiply sTemp whenever we lower the temperature (0~1)
	iter			- amount of iterations
	iterAtTemp		- amount of iterations at a temperature
	COULD ADD LOWER LIMIT AS AN ALTERNATIVE ENDING CONDITON, BUT YOU CAN CALCULATE IT (meaning instead of giving a lower bound for the temperature you can just calculate how long with the given step it'll need to reach a certian temperature)
	*/
	public static Solution SA2Opt(TSP tsp, Solution s, double coolingFactor, int iter, int iterAtTemp){
		
		
		//starting temperature of the algorithm
		double sTemp = getInitialTemperature2Opt(tsp, 2000, 0.95);
		
		
		//this variable holds the current solution (random solution at the start)
		Solution cur=s.clone();
		
		
		//this variable holds the next solution that will be generated by the step
		Solution next;
		
		//this variable holds the best solution
		Solution bestS=cur.clone();
		
		//we start with the iter loop
		for(int i = 0 ; i < iter ; i++){
			
			//the inner loop, how many times we run the algorithm at a given temperature
			for(int j = 0 ; j < iterAtTemp ; j++){
				
				//generate a random neighbor
				next=kopt.random2OptStep(cur);
				
				
				//if current is better then next
				if(tsp.getFitness(next) - tsp.getFitness(cur) <= 0){
					cur=next;
					
					//we also compare the current to the total best found (since we can make a worse move)
					if(tsp.getFitness(bestS)>tsp.getFitness(cur)){
						bestS=cur;
					}
					
				}else{
					
					//we ask ourselfs if we randomly add a worse solution
					if(  Math.random()<Math.exp(-( (tsp.getFitness(next) - tsp.getFitness(cur)) / sTemp ) )  ){
						cur=next;
					}
				}
				
				
				
			}
			
			
			
			//we reduce the temperature here
			sTemp=sTemp*coolingFactor;
			
		}
		return bestS;
		
	}
	
	
	
	/*
	same as above but 3opt.
	while in 2opt it allways switches the two edges here it decides (randomly) from one of the 7 combinations that are different from the starting solution.
	
	tsp 			- the tsp 
	s				- the starting solution
	coolingFactor	- how much we multiply sTemp whenever we lower the temperature (0~1)
	iter			- amount of iterations
	iterAtTemp		- amount of iterations at a temperature
	*/
	public static Solution SA3Opt(TSP tsp, Solution s, double coolingFactor, int iter, int iterAtTemp){
		
		
		//starting temperature of the algorithm
		double sTemp = getInitialTemperature3Opt(tsp, 2000, 0.95);
		
		
		//this variable holds the current solution (random solution at the start)
		Solution cur=s.clone();
		
		
		//this variable holds the next solution that will be generated by the step
		Solution next;
		
		//this variable holds the best solution
		Solution bestS=cur.clone();
		
		//we start with the iter loop
		for(int i = 0 ; i < iter ; i++){
			
			//the inner loop, how many times we run the algorithm at a given temperature
			for(int j = 0 ; j < iterAtTemp ; j++){
				
				//generate a random neighbor
				next=kopt.random3OptStep(cur);
				
				
				//if current is better then next
				if(tsp.getFitness(next) - tsp.getFitness(cur) <= 0){
					cur=next;
					
					//we also compare the current to the total best found (since we can make a worse move)
					if(tsp.getFitness(bestS)>tsp.getFitness(cur)){
						bestS=cur;
					}
					
				}else{
					
					//we ask ourselfs if we randomly add a worse solution
					if(  Math.random()<Math.exp(-( (tsp.getFitness(next) - tsp.getFitness(cur)) / sTemp ) )  ){
						cur=next;
					}
				}
				
				
				
			}
			
			
			
			//we reduce the temperature here
			sTemp=sTemp*coolingFactor;
			
		}
		
		return bestS;
		
	}
	
	
	
	
	
	/*
	https://link.springer.com/article/10.1023/B:COAP.0000044187.23143.bd
	tsp - the tsp
	howMany - how many random solutions will we use to estimate the temperature
	startPercentage - the estimated start percentage
	*/
	public static double getInitialTemperature2Opt(TSP tsp, int howMany, double startPercentage){
		
		//p in the equation
		double p=2;
		
		//Temperature (dosent matter starting point)
		double T=12345;
		
		//Neighborhood sum
		double neighSum=0;
		
		//solution sums
		double solsSum=0;
		
		//value of solsSum/neighSum
		double theValue=0;
		
		//generate random solutions
		Solution[] sols = new Solution[howMany];
		
		//neighbor solutions of the above
		Solution[] neigh = new Solution[howMany];
		
		//initialize them
		for(int i = 0 ; i < howMany ; i++){
			sols[i] = new Solution(tsp.howManyCities());
		}
		
		//get random neighbor
		for(int i = 0 ; i < howMany ; i++){
			neigh[i] = kopt.firstBest2Opt(sols[i], tsp, tsp.howManyCities()*3);
		}
		
		//calculate the upper sum
		for(int i = 0 ; i < howMany ; i++){
			//System.out.println("just added " + Math.exp(-(tsp.getFitness(sols[i])/T)));
			neighSum+=Math.exp(-(tsp.getFitness(neigh[i])/T));
		}
		
		//calculate the lower sum
		for(int i = 0 ; i < howMany ; i++){
			solsSum+=Math.exp(-(tsp.getFitness(sols[i])/T));
		}
		
		theValue=solsSum/neighSum;
		
		//added artificial limit to stop it from bricking
		for(int lim = 0 ; lim < 1000 && Math.abs(theValue-startPercentage)>0.0000000000000001 ; lim++){
			
			//Calculate the next temperature
			T = T * Math.pow(Math.log(solsSum/neighSum)/Math.log(startPercentage), 1/p);
			
			//Reset the sums
			neighSum=0;
			solsSum=0;
			
			//calculate the upper sum
			for(int i = 0 ; i < howMany ; i++){
				neighSum+=Math.exp(-(tsp.getFitness(neigh[i])/T));
			}
			
			//calculate the lower sum
			for(int i = 0 ; i < howMany ; i++){
				solsSum+=Math.exp(-(tsp.getFitness(sols[i])/T));
			}
			
			//Calculate the value for the next iteration
			theValue=solsSum/neighSum;
		}
		
		return T;
		
	}
	
	
	
	
	public static double getInitialTemperature3Opt(TSP tsp, int howMany, double startPercentage){
		
		//p in the equation
		double p=2;
		
		//Temperature (dosent matter starting point)
		double T=12345;
		
		//Neighborhood sum
		double neighSum=0;
		
		//solution sums
		double solsSum=0;
		
		//value of solsSum/neighSum
		double theValue=0;
		
		//generate random solutions
		Solution[] sols = new Solution[howMany];
		
		//neighbor solutions of the above
		Solution[] neigh = new Solution[howMany];
		
		//initialize them
		for(int i = 0 ; i < howMany ; i++){
			sols[i] = new Solution(tsp.howManyCities());
		}
		
		//get random neighbor
		for(int i = 0 ; i < howMany ; i++){
			neigh[i] = kopt.firstBest3Opt(sols[i], tsp, tsp.howManyCities()*3);
		}
		
		//calculate the upper sum
		for(int i = 0 ; i < howMany ; i++){
			//System.out.println("just added " + Math.exp(-(tsp.getFitness(sols[i])/T)));
			neighSum+=Math.exp(-(tsp.getFitness(neigh[i])/T));
		}
		
		//calculate the lower sum
		for(int i = 0 ; i < howMany ; i++){
			solsSum+=Math.exp(-(tsp.getFitness(sols[i])/T));
		}
		
		theValue=solsSum/neighSum;
		
		//added artificial limit to stop it from bricking
		for(int lim = 0 ; lim < 1000 && Math.abs(theValue-startPercentage)>0.0000000000000001 ; lim++){
			
			//Calculate the next temperature
			T = T * Math.pow(Math.log(solsSum/neighSum)/Math.log(startPercentage), 1/p);
			
			//Reset the sums
			neighSum=0;
			solsSum=0;
			
			//calculate the upper sum
			for(int i = 0 ; i < howMany ; i++){
				neighSum+=Math.exp(-(tsp.getFitness(neigh[i])/T));
			}
			
			//calculate the lower sum
			for(int i = 0 ; i < howMany ; i++){
				solsSum+=Math.exp(-(tsp.getFitness(sols[i])/T));
			}
			
			//Calculate the value for the next iteration
			theValue=solsSum/neighSum;
		}
		
		return T;
		
	}
	
	
	
	
	
}









